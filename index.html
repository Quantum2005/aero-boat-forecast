<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Aero Boat Forecast â€” Split Flap</title>
  <style>
    :root {
      --wood-dark: #4f301c;
      --wood-light: #7a4c2e;
      --tile: #171a21;
      --tile-top: #232733;
      --text: #f8fbff;
      --text-old: #ff5252;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      padding: 24px;
      display: grid;
      place-items: center;
      font-family: "Inter", Arial, sans-serif;
      background:
        linear-gradient(90deg, rgba(0, 0, 0, 0.35), rgba(0, 0, 0, 0.2)),
        repeating-linear-gradient(90deg, var(--wood-dark) 0 18px, var(--wood-light) 18px 36px);
    }

    .zoom-wrap {
      transform: scale(0.9);
      transform-origin: center;
    }

    .shell {
      width: min(1260px, 96vw);
      background: linear-gradient(#1e2129, #12141b);
      border: 12px solid #05070d;
      border-radius: 8px;
      box-shadow: 0 18px 60px rgba(0, 0, 0, 0.6), inset 0 0 40px rgba(255, 255, 255, 0.03);
      padding: 20px;
    }

    .title-stack {
      display: grid;
      gap: 10px;
      margin-bottom: 14px;
      border-bottom: 2px solid rgba(255, 255, 255, 0.08);
      padding-bottom: 12px;
    }

    .solid-box {
      background: linear-gradient(#2a3040, #1b1f2a);
      border: 1px solid #343d53;
      border-radius: 6px;
      color: #f6faff;
      font-weight: 800;
      letter-spacing: 5px;
      text-transform: uppercase;
      text-align: center;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
      padding: 12px 16px;
    }

    .solid-box.title {
      font-size: clamp(28px, 2.4vw, 42px);
    }

    .solid-box.columns {
      font-size: clamp(20px, 1.75vw, 30px);
    }

    .rows { display: grid; gap: 8px; }

    .row {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .tile {
      position: relative;
      width: min(3.15vw, 44px);
      aspect-ratio: 1 / 1.26;
      border: 1px solid #2f3748;
      border-radius: 3px;
      overflow: hidden;
      background: linear-gradient(var(--tile-top), var(--tile));
      box-shadow: inset 0 -10px 14px rgba(0, 0, 0, 0.45), inset 0 1px 0 rgba(255, 255, 255, 0.07);
      isolation: isolate;
      perspective: 450px;
    }

    .tile::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      border-top: 1px solid rgba(255, 255, 255, 0.25);
      border-bottom: 1px solid rgba(0, 0, 0, 0.74);
      z-index: 8;
      pointer-events: none;
    }

    .glyph-layer {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      color: var(--text);
      font-size: clamp(26px, 2.35vw, 39px);
      font-weight: 800;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.88);
      pointer-events: none;
      z-index: 2;
      transition: color 220ms ease;
    }

    .glyph-top,
    .glyph-next-top { clip-path: inset(0 0 50% 0); }

    .glyph-bottom,
    .glyph-next-bottom { clip-path: inset(50% 0 0 0); }

    .glyph-next-top,
    .glyph-next-bottom {
      opacity: 0;
      z-index: 3;
    }

    .tile.space .glyph-layer { color: transparent; }

    .tile.old .glyph-layer {
      color: var(--text-old);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8), 0 0 7px rgba(255, 82, 82, 0.45);
    }

    .flap-top,
    .flap-bottom {
      position: absolute;
      left: 0;
      width: 100%;
      height: 50%;
      z-index: 6;
      background: linear-gradient(rgba(36, 42, 56, 0.46), rgba(15, 19, 28, 0.46));
      pointer-events: none;
      backface-visibility: hidden;
    }

    .flap-top { top: 0; transform-origin: bottom; }
    .flap-bottom { bottom: 0; transform-origin: top; transform: rotateX(90deg); }

    .tile.flipping .flap-top { animation: topFlip 200ms ease-in forwards; }
    .tile.flipping .flap-bottom { animation: bottomFlip 200ms ease-out 200ms forwards; }
    .tile.flipping .glyph-next-top,
    .tile.flipping .glyph-next-bottom { opacity: 1; }

    .separator {
      width: min(2vw, 28px);
      text-align: center;
      color: #dce7ff;
      font-weight: 800;
      font-size: clamp(22px, 2vw, 32px);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.9);
      line-height: 1;
    }

    @keyframes topFlip {
      from { transform: rotateX(0deg); background: linear-gradient(rgba(36, 42, 56, 0.46), rgba(15, 19, 28, 0.46)); }
      to { transform: rotateX(-90deg); background: linear-gradient(rgba(36, 42, 56, 0.92), rgba(15, 19, 28, 0.92)); }
    }

    @keyframes bottomFlip {
      from { transform: rotateX(90deg); background: linear-gradient(rgba(36, 42, 56, 0.92), rgba(15, 19, 28, 0.92)); }
      to { transform: rotateX(0deg); background: linear-gradient(rgba(36, 42, 56, 0.46), rgba(15, 19, 28, 0.46)); }
    }

    @media (max-width: 900px) {
      .tile { width: min(4.4vw, 36px); }
    }
  </style>
</head>
<body>
  <div class="zoom-wrap">
    <main class="shell">
      <section class="title-stack">
        <div class="solid-box title">Daily Forecast</div>
        <div class="solid-box columns">Server ID &nbsp;|&nbsp; Multiplier &nbsp;|&nbsp; Category</div>
      </section>

      <section class="rows" id="dataRows"></section>
    </main>
  </div>

  <script>
    const SERVER_WIDTH = 10;
    const MULTIPLIER_WIDTH = 8;
    const CATEGORY_WIDTH = 8;

    let forecastData = [
      { server: "2B61B1", multiplier: "1.18x", category: "new" },
      { server: "DD616C", multiplier: "1.17x", category: "new" },
      { server: "FB81A4", multiplier: "1.17x", category: "new" },
      { server: "457091", multiplier: "1.16x", category: "new" },
      { server: "CBCABF", multiplier: "1.16x", category: "new" },
      { server: "95CF99", multiplier: "1.13x", category: "new" },
      { server: "A94F7B", multiplier: "1.09x", category: "new" },
      { server: "09D872", multiplier: "1.08x", category: "old" },
      { server: "40660D", multiplier: "1.03x", category: "old" },
      { server: "03FC99", multiplier: "1.02x", category: "old" },
      { server: "5358F7", multiplier: "1.01x", category: "old" }
    ];

    let lastSnapshot = JSON.stringify(forecastData);

    function normalize(text, width) {
      return String(text).toUpperCase().slice(0, width).padEnd(width, " ");
    }

    function isOld(category) {
      return String(category || "").toLowerCase() === "old";
    }

    function createGlyph(className, char) {
      const glyph = document.createElement("div");
      glyph.className = `glyph-layer ${className}`;
      glyph.textContent = char;
      return glyph;
    }

    function createTile(char, old = false) {
      const tile = document.createElement("div");
      tile.className = "tile";
      if (char === " ") tile.classList.add("space");
      if (old) tile.classList.add("old");

      const glyphTop = createGlyph("glyph-top", char);
      const glyphBottom = createGlyph("glyph-bottom", char);
      const glyphNextTop = createGlyph("glyph-next-top", char);
      const glyphNextBottom = createGlyph("glyph-next-bottom", char);

      const flapTop = document.createElement("div");
      flapTop.className = "flap-top";

      const flapBottom = document.createElement("div");
      flapBottom.className = "flap-bottom";

      tile.append(glyphTop, glyphBottom, glyphNextTop, glyphNextBottom, flapTop, flapBottom);

      return {
        tile,
        glyphTop,
        glyphBottom,
        glyphNextTop,
        glyphNextBottom,
        char,
        queue: Promise.resolve()
      };
    }

    const rowTiles = [];

    function buildDataRows(data) {
      const dataRows = document.getElementById("dataRows");
      dataRows.innerHTML = "";
      rowTiles.length = 0;

      data.forEach((entry) => {
        const row = document.createElement("div");
        row.className = "row";
        const old = isOld(entry.category);

        const serverTiles = [];
        [...normalize(entry.server, SERVER_WIDTH)].forEach((char) => {
          const tileObj = createTile(char, old);
          serverTiles.push(tileObj);
          row.appendChild(tileObj.tile);
        });

        const sep1 = document.createElement("div");
        sep1.className = "separator";
        sep1.textContent = "|";
        row.appendChild(sep1);

        const multTiles = [];
        [...normalize(entry.multiplier, MULTIPLIER_WIDTH)].forEach((char) => {
          const tileObj = createTile(char, old);
          multTiles.push(tileObj);
          row.appendChild(tileObj.tile);
        });

        const sep2 = document.createElement("div");
        sep2.className = "separator";
        sep2.textContent = "|";
        row.appendChild(sep2);

        const categoryTiles = [];
        [...normalize(entry.category, CATEGORY_WIDTH)].forEach((char) => {
          const tileObj = createTile(char, old);
          categoryTiles.push(tileObj);
          row.appendChild(tileObj.tile);
        });

        rowTiles.push({ serverTiles, multTiles, categoryTiles });
        dataRows.appendChild(row);
      });
    }

    function wait(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function flipOnce(tileObj, targetChar, old) {
      tileObj.glyphNextTop.textContent = targetChar;
      tileObj.glyphNextBottom.textContent = targetChar;
      tileObj.tile.classList.toggle("old", old);
      tileObj.tile.classList.add("flipping");
      await wait(420);
      tileObj.glyphTop.textContent = targetChar;
      tileObj.glyphBottom.textContent = targetChar;
      tileObj.char = targetChar;
      tileObj.tile.classList.toggle("space", targetChar === " ");
      tileObj.tile.classList.toggle("old", old);
      tileObj.tile.classList.remove("flipping");
    }

    function enqueueFlipTo(tileObj, targetChar, delay = 0, old = false) {
      tileObj.queue = tileObj.queue.then(async () => {
        if (tileObj.char === targetChar && tileObj.tile.classList.contains("old") === old) return;
        await wait(delay);
        await flipOnce(tileObj, targetChar, old);
      });
      return tileObj.queue;
    }

    function animateToData(data) {
      const tasks = [];
      data.forEach((entry, rowIndex) => {
        const server = normalize(entry.server, SERVER_WIDTH);
        const multiplier = normalize(entry.multiplier, MULTIPLIER_WIDTH);
        const category = normalize(entry.category, CATEGORY_WIDTH);
        const old = isOld(entry.category);

        [...server].forEach((char, i) => {
          tasks.push(enqueueFlipTo(rowTiles[rowIndex].serverTiles[i], char, i * 20, old));
        });

        [...multiplier].forEach((char, i) => {
          tasks.push(enqueueFlipTo(rowTiles[rowIndex].multTiles[i], char, i * 20 + 75, old));
        });

        [...category].forEach((char, i) => {
          tasks.push(enqueueFlipTo(rowTiles[rowIndex].categoryTiles[i], char, i * 20 + 130, old));
        });
      });

      return Promise.all(tasks);
    }

    function fetchForecastData() {
      if (typeof window.getForecastData === "function") {
        const result = window.getForecastData();
        if (Array.isArray(result)) return result;
      }
      return forecastData;
    }

    async function refreshBoard() {
      const latest = fetchForecastData();
      const snapshot = JSON.stringify(latest);
      if (snapshot === lastSnapshot) return;

      if (latest.length !== rowTiles.length) {
        buildDataRows(latest);
      }

      await animateToData(latest);
      forecastData = latest;
      lastSnapshot = snapshot;
    }

    buildDataRows(forecastData);
    window.refreshBoard = refreshBoard;
    setInterval(refreshBoard, 30000);
  </script>
</body>
</html>
