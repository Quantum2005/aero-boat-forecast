<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Aero Boat Forecast â€” Split Flap</title>
  <style>
    :root {
      --wood-dark: #4f301c;
      --wood-light: #7a4c2e;
      --tile: #171a21;
      --tile-top: #232733;
      --text: #f9fcff;
      --text-old: #ff5a5a;
      --text-unstable: #ffd84d;
      --tile-w: min(2.9vw, 38px);
      --tile-gap: 4px;
      --seg-sep: min(2vw, 24px);
      --server-count: 10;
      --mult-count: 8;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      padding: 24px;
      display: grid;
      place-items: center;
      font-family: "Inter", Arial, sans-serif;
      background:
        linear-gradient(90deg, rgba(0, 0, 0, 0.35), rgba(0, 0, 0, 0.2)),
        repeating-linear-gradient(90deg, var(--wood-dark) 0 18px, var(--wood-light) 18px 36px);
    }

    .scale-frame {
      transform: scale(0.9);
      transform-origin: center;
    }

    .shell {
      width: min(1180px, 96vw);
      background: linear-gradient(#1e2129, #12141b);
      border: 10px solid #05070d;
      border-radius: 8px;
      box-shadow: 0 18px 60px rgba(0, 0, 0, 0.6), inset 0 0 40px rgba(255, 255, 255, 0.03);
      padding: 18px;
    }

    .solid-box {
      background: linear-gradient(180deg, #1f2736, #101722);
      border: 1px solid #2a3447;
      border-radius: 4px;
      color: var(--text);
      font-weight: 800;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.75);
      display: flex;
      align-items: center;
    }

    .title-box {
      justify-content: center;
      font-size: clamp(22px, 2.2vw, 34px);
      padding: 14px 18px;
      margin-bottom: 10px;
    }

    .header-box {
      font-size: clamp(19px, 1.9vw, 28px);
      padding: 12px 0;
      margin-bottom: 10px;
      display: grid;
      grid-template-columns:
        calc((var(--server-count) * var(--tile-w)) + ((var(--server-count) - 1) * var(--tile-gap)))
        var(--seg-sep)
        calc((var(--mult-count) * var(--tile-w)) + ((var(--mult-count) - 1) * var(--tile-gap)));
      justify-content: start;
      align-items: center;
      column-gap: var(--tile-gap);
    }

    .header-box span { text-align: center; }
    .header-box .header-left { text-align: center; }
    .header-box .header-right { text-align: center; }

    .rows { display: grid; gap: 8px; }
    .row { display: flex; align-items: center; gap: var(--tile-gap); }

    .tile {
      position: relative;
      width: var(--tile-w);
      aspect-ratio: 1 / 1.28;
      border: 1px solid #242a35;
      border-radius: 3px;
      overflow: hidden;
      background: linear-gradient(var(--tile-top), var(--tile));
      box-shadow: inset 0 -10px 14px rgba(0, 0, 0, 0.45), inset 0 1px 0 rgba(255, 255, 255, 0.05);
      isolation: isolate;
      perspective: 400px;
    }

    .tile::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      border-top: 1px solid rgba(255, 255, 255, 0.22);
      border-bottom: 1px solid rgba(0, 0, 0, 0.7);
      z-index: 8;
      pointer-events: none;
    }

    .glyph-layer {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      color: var(--text);
      font-size: clamp(25px, 2.6vw, 42px);
      font-weight: 800;
      line-height: 1;
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.9);
      pointer-events: none;
      z-index: 2;
    }

    .tile.old .glyph-layer {
      color: var(--text-old);
      text-shadow: 0 0 10px rgba(255, 60, 60, 0.2), 0 1px 1px rgba(0, 0, 0, 0.9);
    }

    .tile.unstable .glyph-layer {
      color: var(--text-unstable);
      text-shadow: 0 0 10px rgba(255, 223, 92, 0.22), 0 1px 1px rgba(0, 0, 0, 0.9);
    }

    .glyph-top,
    .glyph-next-top { clip-path: inset(0 0 50% 0); }

    .glyph-bottom,
    .glyph-next-bottom { clip-path: inset(50% 0 0 0); }

    .glyph-next-top,
    .glyph-next-bottom {
      opacity: 0;
      z-index: 3;
    }

    .tile.space .glyph-layer { color: transparent !important; }

    .flap-top,
    .flap-bottom {
      position: absolute;
      left: 0;
      width: 100%;
      height: 50%;
      z-index: 6;
      background: linear-gradient(rgba(36, 42, 56, 0.5), rgba(15, 19, 28, 0.5));
      pointer-events: none;
      backface-visibility: hidden;
    }

    .flap-top { top: 0; transform-origin: bottom; }
    .flap-bottom { bottom: 0; transform-origin: top; transform: rotateX(90deg); }

    .tile.flipping .flap-top { animation: topFlip 140ms ease-in forwards; }
    .tile.flipping .flap-bottom { animation: bottomFlip 140ms ease-out 140ms forwards; }
    .tile.flipping .glyph-next-top,
    .tile.flipping .glyph-next-bottom { opacity: 1; }

    .separator {
      width: var(--seg-sep);
      text-align: center;
      color: #d4deef;
      font-weight: 800;
      font-size: clamp(20px, 1.6vw, 24px);
    }

    @keyframes topFlip {
      from { transform: rotateX(0deg); background: linear-gradient(rgba(36, 42, 56, 0.5), rgba(15, 19, 28, 0.5)); }
      to { transform: rotateX(-90deg); background: linear-gradient(rgba(36, 42, 56, 0.95), rgba(15, 19, 28, 0.95)); }
    }

    @keyframes bottomFlip {
      from { transform: rotateX(90deg); background: linear-gradient(rgba(36, 42, 56, 0.95), rgba(15, 19, 28, 0.95)); }
      to { transform: rotateX(0deg); background: linear-gradient(rgba(36, 42, 56, 0.5), rgba(15, 19, 28, 0.5)); }
    }

    @media (max-width: 900px) {
      :root { --tile-w: min(4vw, 34px); }
    }
  </style>
</head>
<body>
  <div class="scale-frame">
    <main class="shell">
      <section class="solid-box title-box">Daily Forecast</section>
      <section class="solid-box header-box">
        <span class="header-left">Server ID</span>
        <span>|</span>
        <span class="header-right">Multiplier</span>
      </section>
      <section class="rows" id="dataRows"></section>
    </main>
  </div>

  <script>
    const SERVER_WIDTH = 10;
    const MULTIPLIER_WIDTH = 8;
    const ALPHABET = " ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-X";
    const CATEGORY_ORDER = ["normal", "old", "unstable"];

    let forecastData = [
      { server: "2B61B1", multiplier: "1.18x", category: "normal" },
      { server: "DD616C", multiplier: "1.17x", category: "old" },
      { server: "FB81A4", multiplier: "1.17x", category: "unstable" },
      { server: "457091", multiplier: "1.16x", category: "normal" },
      { server: "CBCABF", multiplier: "1.16x", category: "old" }
    ];

    let lastSnapshot = JSON.stringify(forecastData);

    function getStoredForecastData() {
      try {
        const raw = localStorage.getItem("forecastData");
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return null;
        return parsed;
      } catch {
        return null;
      }
    }

    function normalizeCategory(value) {
      if (value === "old" || value === "unstable") return value;
      return "normal";
    }

    function normalizeEntry(entry) {
      return {
        server: String(entry.server ?? ""),
        multiplier: String(entry.multiplier ?? ""),
        category: normalizeCategory(entry.category)
      };
    }

    const storedData = getStoredForecastData();
    if (storedData) {
      forecastData = storedData.map(normalizeEntry);
      lastSnapshot = JSON.stringify(forecastData);
    }

    function normalize(text, width) {
      return String(text).toUpperCase().slice(0, width).padEnd(width, " ");
    }

    function createGlyph(className, char) {
      const glyph = document.createElement("div");
      glyph.className = `glyph-layer ${className}`;
      glyph.textContent = char;
      return glyph;
    }

    function applyCategoryClass(tile, category) {
      tile.classList.remove("old", "unstable");
      if (category === "old") tile.classList.add("old");
      if (category === "unstable") tile.classList.add("unstable");
    }

    function createTile(char, category) {
      const tile = document.createElement("div");
      tile.className = "tile";
      if (char === " ") tile.classList.add("space");
      applyCategoryClass(tile, category);

      const glyphTop = createGlyph("glyph-top", char);
      const glyphBottom = createGlyph("glyph-bottom", char);
      const glyphNextTop = createGlyph("glyph-next-top", char);
      const glyphNextBottom = createGlyph("glyph-next-bottom", char);

      const flapTop = document.createElement("div");
      flapTop.className = "flap-top";

      const flapBottom = document.createElement("div");
      flapBottom.className = "flap-bottom";

      tile.append(glyphTop, glyphBottom, glyphNextTop, glyphNextBottom, flapTop, flapBottom);

      return {
        tile,
        glyphTop,
        glyphBottom,
        glyphNextTop,
        glyphNextBottom,
        char,
        category,
        queue: Promise.resolve()
      };
    }

    const rowTiles = [];

    function buildDataRows(data) {
      const dataRows = document.getElementById("dataRows");
      dataRows.innerHTML = "";
      rowTiles.length = 0;

      data.forEach((entryRaw) => {
        const entry = normalizeEntry(entryRaw);
        const row = document.createElement("div");
        row.className = "row";

        const serverTiles = [];
        [...normalize(entry.server, SERVER_WIDTH)].forEach((char) => {
          const tileObj = createTile(char, entry.category);
          serverTiles.push(tileObj);
          row.appendChild(tileObj.tile);
        });

        const sep = document.createElement("div");
        sep.className = "separator";
        sep.textContent = "|";
        row.appendChild(sep);

        const multTiles = [];
        [...normalize(entry.multiplier, MULTIPLIER_WIDTH)].forEach((char) => {
          const tileObj = createTile(char, entry.category);
          multTiles.push(tileObj);
          row.appendChild(tileObj.tile);
        });

        rowTiles.push({ serverTiles, multTiles, category: entry.category });
        dataRows.appendChild(row);
      });
    }

    function wait(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function flipOnce(tileObj, targetChar, targetCategory) {
      tileObj.glyphNextTop.textContent = targetChar;
      tileObj.glyphNextBottom.textContent = targetChar;
      applyCategoryClass(tileObj.tile, targetCategory);
      tileObj.tile.classList.add("flipping");

      await wait(300);

      tileObj.glyphTop.textContent = targetChar;
      tileObj.glyphBottom.textContent = targetChar;
      tileObj.char = targetChar;
      tileObj.category = targetCategory;
      tileObj.tile.classList.toggle("space", targetChar === " ");
      applyCategoryClass(tileObj.tile, targetCategory);
      tileObj.tile.classList.remove("flipping");
    }

    function enqueueFlipTo(tileObj, targetChar, targetCategory, delay = 0, force = false) {
      tileObj.queue = tileObj.queue.then(async () => {
        const sameChar = tileObj.char === targetChar;
        const sameCategory = tileObj.category === targetCategory;
        if (!force && sameChar && sameCategory) return;
        await wait(delay);
        await flipOnce(tileObj, targetChar, targetCategory);
      });
      return tileObj.queue;
    }

    function animateToData(data) {
      const tasks = [];
      data.forEach((entryRaw, rowIndex) => {
        const entry = normalizeEntry(entryRaw);
        const server = normalize(entry.server, SERVER_WIDTH);
        const multiplier = normalize(entry.multiplier, MULTIPLIER_WIDTH);
        const categoryChanged = rowTiles[rowIndex].category !== entry.category;

        [...server].forEach((char, i) => {
          tasks.push(enqueueFlipTo(rowTiles[rowIndex].serverTiles[i], char, entry.category, i * 24, categoryChanged));
        });

        [...multiplier].forEach((char, i) => {
          tasks.push(enqueueFlipTo(rowTiles[rowIndex].multTiles[i], char, entry.category, i * 24 + 90, categoryChanged));
        });

        rowTiles[rowIndex].category = entry.category;
      });

      return Promise.all(tasks);
    }

    function randomChar() {
      return ALPHABET[Math.floor(Math.random() * ALPHABET.length)];
    }

    function randomCategory() {
      return CATEGORY_ORDER[Math.floor(Math.random() * CATEGORY_ORDER.length)];
    }

    async function runShuffleAnimation(targetData) {
      const phases = 3;
      const tasks = [];

      targetData.forEach((entryRaw, rowIndex) => {
        const entry = normalizeEntry(entryRaw);
        const server = normalize(entry.server, SERVER_WIDTH);
        const multiplier = normalize(entry.multiplier, MULTIPLIER_WIDTH);

        [...server].forEach((char, i) => {
          const tile = rowTiles[rowIndex].serverTiles[i];
          for (let phase = 0; phase < phases; phase += 1) {
            tasks.push(enqueueFlipTo(tile, randomChar(), randomCategory(), phase * 80 + i * 10, true));
          }
          tasks.push(enqueueFlipTo(tile, char, entry.category, phases * 80 + i * 10, true));
        });

        [...multiplier].forEach((char, i) => {
          const tile = rowTiles[rowIndex].multTiles[i];
          for (let phase = 0; phase < phases; phase += 1) {
            tasks.push(enqueueFlipTo(tile, randomChar(), randomCategory(), phase * 80 + i * 10 + 70, true));
          }
          tasks.push(enqueueFlipTo(tile, char, entry.category, phases * 80 + i * 10 + 70, true));
        });
      });

      await Promise.all(tasks);
    }

    function fetchForecastData() {
      if (typeof window.getForecastData === "function") {
        const result = window.getForecastData();
        if (Array.isArray(result)) return result.map(normalizeEntry);
      }

      const stored = getStoredForecastData();
      if (stored) return stored.map(normalizeEntry);

      return forecastData.map(normalizeEntry);
    }

    async function refreshBoard({ withShuffle = false } = {}) {
      const latest = fetchForecastData();
      const snapshot = JSON.stringify(latest);

      if (latest.length !== rowTiles.length) {
        buildDataRows(latest);
      }

      if (withShuffle) {
        await runShuffleAnimation(latest);
      } else if (snapshot !== lastSnapshot) {
        await animateToData(latest);
      }

      forecastData = latest;
      lastSnapshot = snapshot;
    }

    buildDataRows(forecastData);
    window.refreshBoard = refreshBoard;
    setInterval(() => refreshBoard({ withShuffle: true }), 30000);
  </script>
</body>
</html>
