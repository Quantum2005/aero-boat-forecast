<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Aero Boat Forecast â€” Split Flap</title>
  <style>
    :root {
      --wood-dark: #4f301c;
      --wood-light: #7a4c2e;
      --tile: #171a21;
      --tile-top: #232733;
      --text: #f9fcff;
      --text-old: #ff5a5a;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      padding: 24px;
      display: grid;
      place-items: center;
      font-family: "Inter", Arial, sans-serif;
      background:
        linear-gradient(90deg, rgba(0, 0, 0, 0.35), rgba(0, 0, 0, 0.2)),
        repeating-linear-gradient(90deg, var(--wood-dark) 0 18px, var(--wood-light) 18px 36px);
    }

    .scale-frame {
      transform: scale(0.9);
      transform-origin: center;
    }

    .shell {
      width: min(1180px, 96vw);
      background: linear-gradient(#1e2129, #12141b);
      border: 10px solid #05070d;
      border-radius: 8px;
      box-shadow: 0 18px 60px rgba(0, 0, 0, 0.6), inset 0 0 40px rgba(255, 255, 255, 0.03);
      padding: 18px;
    }

    .solid-box {
      background: linear-gradient(180deg, #1f2736, #101722);
      border: 1px solid #2a3447;
      border-radius: 4px;
      color: var(--text);
      font-weight: 800;
      letter-spacing: 0.22em;
      text-transform: uppercase;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.75);
      display: flex;
      align-items: center;
    }

    .title-box {
      justify-content: center;
      font-size: clamp(22px, 2.2vw, 34px);
      padding: 14px 18px;
      margin-bottom: 10px;
    }

    .header-box {
      justify-content: flex-start;
      font-size: clamp(19px, 1.9vw, 28px);
      padding: 12px 14px;
      margin-bottom: 10px;
      gap: 14px;
    }

    .header-left { width: calc((10 * min(2.9vw, 38px)) + (9 * 4px)); }
    .header-sep { width: min(2vw, 24px); text-align: center; color: #d4deef; }

    .rows { display: grid; gap: 8px; }
    .row { display: flex; align-items: center; gap: 4px; }

    .tile {
      position: relative;
      width: min(2.9vw, 38px);
      aspect-ratio: 1 / 1.28;
      border: 1px solid #242a35;
      border-radius: 3px;
      overflow: hidden;
      background: linear-gradient(var(--tile-top), var(--tile));
      box-shadow: inset 0 -10px 14px rgba(0, 0, 0, 0.45), inset 0 1px 0 rgba(255, 255, 255, 0.05);
      isolation: isolate;
      perspective: 400px;
    }

    .tile::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      border-top: 1px solid rgba(255, 255, 255, 0.22);
      border-bottom: 1px solid rgba(0, 0, 0, 0.7);
      z-index: 8;
      pointer-events: none;
    }

    .glyph-layer {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      color: var(--text);
      font-size: clamp(24px, 2.45vw, 40px);
      font-weight: 800;
      line-height: 1;
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.9);
      pointer-events: none;
      z-index: 2;
    }

    .tile.old .glyph-layer {
      color: var(--text-old);
      text-shadow: 0 0 10px rgba(255, 60, 60, 0.15), 0 1px 1px rgba(0, 0, 0, 0.9);
    }

    .glyph-top,
    .glyph-next-top { clip-path: inset(0 0 50% 0); }

    .glyph-bottom,
    .glyph-next-bottom { clip-path: inset(50% 0 0 0); }

    .glyph-next-top,
    .glyph-next-bottom {
      opacity: 0;
      z-index: 3;
    }

    .tile.space .glyph-layer { color: transparent !important; }

    .flap-top,
    .flap-bottom {
      position: absolute;
      left: 0;
      width: 100%;
      height: 50%;
      z-index: 6;
      background: linear-gradient(rgba(36, 42, 56, 0.5), rgba(15, 19, 28, 0.5));
      pointer-events: none;
      backface-visibility: hidden;
    }

    .flap-top { top: 0; transform-origin: bottom; }
    .flap-bottom { bottom: 0; transform-origin: top; transform: rotateX(90deg); }

    .tile.flipping .flap-top { animation: topFlip 200ms ease-in forwards; }
    .tile.flipping .flap-bottom { animation: bottomFlip 200ms ease-out 200ms forwards; }
    .tile.flipping .glyph-next-top,
    .tile.flipping .glyph-next-bottom { opacity: 1; }

    .separator {
      width: min(2vw, 24px);
      text-align: center;
      color: #d4deef;
      font-weight: 800;
      font-size: clamp(20px, 1.6vw, 24px);
    }

    @keyframes topFlip {
      from { transform: rotateX(0deg); background: linear-gradient(rgba(36, 42, 56, 0.5), rgba(15, 19, 28, 0.5)); }
      to { transform: rotateX(-90deg); background: linear-gradient(rgba(36, 42, 56, 0.95), rgba(15, 19, 28, 0.95)); }
    }

    @keyframes bottomFlip {
      from { transform: rotateX(90deg); background: linear-gradient(rgba(36, 42, 56, 0.95), rgba(15, 19, 28, 0.95)); }
      to { transform: rotateX(0deg); background: linear-gradient(rgba(36, 42, 56, 0.5), rgba(15, 19, 28, 0.5)); }
    }

    @media (max-width: 900px) {
      .tile { width: min(4vw, 34px); }
      .header-left { width: calc((10 * min(4vw, 34px)) + (9 * 4px)); }
    }
  </style>
</head>
<body>
  <div class="scale-frame">
    <main class="shell">
      <section class="solid-box title-box">Daily Forecast</section>
      <section class="solid-box header-box">
        <span class="header-left">Server ID</span>
        <span class="header-sep">|</span>
        <span>Multiplier</span>
      </section>
      <section class="rows" id="dataRows"></section>
    </main>
  </div>

  <script>
    const SERVER_WIDTH = 10;
    const MULTIPLIER_WIDTH = 8;

    let forecastData = [
      { server: "2B61B1", multiplier: "1.18x", old: false },
      { server: "DD616C", multiplier: "1.17x", old: true },
      { server: "FB81A4", multiplier: "1.17x", old: false },
      { server: "457091", multiplier: "1.16x", old: false },
      { server: "CBCABF", multiplier: "1.16x", old: true }
    ];

    let lastSnapshot = JSON.stringify(forecastData);

    function normalize(text, width) {
      return String(text).toUpperCase().slice(0, width).padEnd(width, " ");
    }

    function createGlyph(className, char) {
      const glyph = document.createElement("div");
      glyph.className = `glyph-layer ${className}`;
      glyph.textContent = char;
      return glyph;
    }

    function createTile(char, isOld) {
      const tile = document.createElement("div");
      tile.className = "tile";
      if (char === " ") tile.classList.add("space");
      if (isOld) tile.classList.add("old");

      const glyphTop = createGlyph("glyph-top", char);
      const glyphBottom = createGlyph("glyph-bottom", char);
      const glyphNextTop = createGlyph("glyph-next-top", char);
      const glyphNextBottom = createGlyph("glyph-next-bottom", char);

      const flapTop = document.createElement("div");
      flapTop.className = "flap-top";

      const flapBottom = document.createElement("div");
      flapBottom.className = "flap-bottom";

      tile.append(glyphTop, glyphBottom, glyphNextTop, glyphNextBottom, flapTop, flapBottom);

      return {
        tile,
        glyphTop,
        glyphBottom,
        glyphNextTop,
        glyphNextBottom,
        char,
        old: Boolean(isOld),
        queue: Promise.resolve()
      };
    }

    const rowTiles = [];

    function buildDataRows(data) {
      const dataRows = document.getElementById("dataRows");
      dataRows.innerHTML = "";
      rowTiles.length = 0;

      data.forEach((entry) => {
        const row = document.createElement("div");
        row.className = "row";

        const serverTiles = [];
        [...normalize(entry.server, SERVER_WIDTH)].forEach((char) => {
          const tileObj = createTile(char, entry.old);
          serverTiles.push(tileObj);
          row.appendChild(tileObj.tile);
        });

        const sep = document.createElement("div");
        sep.className = "separator";
        sep.textContent = "|";
        row.appendChild(sep);

        const multTiles = [];
        [...normalize(entry.multiplier, MULTIPLIER_WIDTH)].forEach((char) => {
          const tileObj = createTile(char, entry.old);
          multTiles.push(tileObj);
          row.appendChild(tileObj.tile);
        });

        rowTiles.push({ serverTiles, multTiles, old: Boolean(entry.old) });
        dataRows.appendChild(row);
      });
    }

    function wait(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    async function flipOnce(tileObj, targetChar, targetOld) {
      tileObj.glyphNextTop.textContent = targetChar;
      tileObj.glyphNextBottom.textContent = targetChar;
      tileObj.tile.classList.toggle("old", targetOld);
      tileObj.tile.classList.add("flipping");

      await wait(420);

      tileObj.glyphTop.textContent = targetChar;
      tileObj.glyphBottom.textContent = targetChar;
      tileObj.char = targetChar;
      tileObj.old = targetOld;
      tileObj.tile.classList.toggle("space", targetChar === " ");
      tileObj.tile.classList.toggle("old", targetOld);
      tileObj.tile.classList.remove("flipping");
    }

    function enqueueFlipTo(tileObj, targetChar, targetOld, delay = 0, force = false) {
      tileObj.queue = tileObj.queue.then(async () => {
        const sameChar = tileObj.char === targetChar;
        const sameOld = tileObj.old === targetOld;
        if (!force && sameChar && sameOld) return;
        await wait(delay);
        await flipOnce(tileObj, targetChar, targetOld);
      });
      return tileObj.queue;
    }

    function animateToData(data) {
      const tasks = [];
      data.forEach((entry, rowIndex) => {
        const server = normalize(entry.server, SERVER_WIDTH);
        const multiplier = normalize(entry.multiplier, MULTIPLIER_WIDTH);
        const targetOld = Boolean(entry.old);
        const oldChanged = rowTiles[rowIndex].old !== targetOld;

        [...server].forEach((char, i) => {
          tasks.push(enqueueFlipTo(rowTiles[rowIndex].serverTiles[i], char, targetOld, i * 24, oldChanged));
        });

        [...multiplier].forEach((char, i) => {
          tasks.push(enqueueFlipTo(rowTiles[rowIndex].multTiles[i], char, targetOld, i * 24 + 90, oldChanged));
        });

        rowTiles[rowIndex].old = targetOld;
      });

      return Promise.all(tasks);
    }

    function fetchForecastData() {
      if (typeof window.getForecastData === "function") {
        const result = window.getForecastData();
        if (Array.isArray(result)) return result;
      }
      return forecastData;
    }

    async function refreshBoard() {
      const latest = fetchForecastData();
      const snapshot = JSON.stringify(latest);
      if (snapshot === lastSnapshot) return;

      if (latest.length !== rowTiles.length) {
        buildDataRows(latest);
      }

      await animateToData(latest);
      forecastData = latest;
      lastSnapshot = snapshot;
    }

    buildDataRows(forecastData);
    window.refreshBoard = refreshBoard;
    setInterval(refreshBoard, 30000);
  </script>
</body>
</html>
